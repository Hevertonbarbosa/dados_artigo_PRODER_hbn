library(forecast)
library(lmtest)
install.packages("forecast")
library(forecast)
library(lmtest)
AirPassengers
vetor <- as.numeric(AirPassengers)
z <- ts(vetor, frequency = 12, start = c(1949,1))
z
ts.plot(z)
seasonplot(z,
col = rainbow(12),
year.labels = TRUE,
type = "o",
pch = 16)
ggtsdisplay(z)
install.packages("ggtsdisplay")
ggtsdisplay(z)
install.packages("ggtsdisplay")
install.packages(c("htmltools", "htmlwidgets", "insight", "knitr", "maptools", "matrixStats", "stringi", "tibble", "vroom", "xfun"))
install.packages("ggtsdisplay")
#ggtsdisplay(z)
lambda <- BoxCox.lambda(z)
install.packages("BoxCox.lambda")
install.packages('forecast', dependencies = TRUE)
library(forecast)
library(lmtest)
AirPassengers
vetor <- as.numeric(AirPassengers)
z <- ts(vetor, frequency = 12, start = c(1949,1))
z
ts.plot(z)
seasonplot(z,
col = rainbow(12),
year.labels = TRUE,
type = "o",
pch = 16)
ggtsdisplay(z)
lambda <- BoxCox.lambda(z)
lambda
library(readxl)
PIB <- read_excel("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/5_Metodos_Quantitativos/Artigo_Metodos_Quantitativos/PIB.xlsx")
View(PIB)
TPIB = ts(PIB, start = c(2010), end = c(2018), frequency = 1)
plot(TPIB)
PPIB = TPIB[,2]
plot(PPIB)
plot(PPIB, main='PIB do Cariri', x)
plot(PPIB, main='PIB do Cariri')
library(readxl)
PIB <- read_excel("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/5_Metodos_Quantitativos/Artigo_Metodos_Quantitativos/PIB.xlsx")
View(PIB)
TPIB = ts(PIB, start = c(2010), end = c(2018), frequency = 1)
plot(TPIB)
PPIB = TPIB[,2]
plot(PPIB, main='PIB do Cariri')
install.packages('forecast', dependencies = TRUE)
library(forecast)
library(lmtest)
AirPassengers
vetor <- as.numeric(AirPassengers)
z <- ts(vetor, frequency = 12, start = c(1949,1))
z
ts.plot(z)
seasonplot(z,
col = rainbow(12),
year.labels = TRUE,
type = "o",
pch = 16)
ggtsdisplay(z)
lambda <- BoxCox.lambda(z)
vetor <- as.numeric(AirPassengers)
library(readxl)
PIB <- read_excel("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/5_Metodos_Quantitativos/Artigo_Metodos_Quantitativos/PIB.xlsx")
View(PIB)
TPIB = ts(PIB, start = c(2010), end = c(2018), frequency = 1)
plot(TPIB)
PPIB = TPIB[,2]
plot(PPIB, main='PIB do Cariri')
x<-(14,54,72,52,33,10,5)
x<-c(14,54,72,52,33,10,5)
hist(x)
lines(density(x))
library(dados)
library(esquisse)
install.packages("dados")
install.packages("esquisse")
library(dados)
library(esquisse)
pinguins <- dados::pinguins
pinguins <- dados:: pinguins
pinguins <- dados :: pinguins
pinguins <-dados :: pinguins
pinguins<-dados :: pinguins
esquisse::esquisser()
#install: source("http://bioconductor.org/biocLite.R"); biocLite("EBImage")
library("EBImage")
source("http://bioconductor.org/biocLite.R"); biocLite("EBImage")
install: source("http://bioconductor.org/biocLite.R"); biocLite("EBImage")
library("EBImage")
source("http://bioconductor.org/biocLite.R"); biocLite("EBImage")
#endere√ßo para abertura de imagem
aux<-EBImage::readImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.png")
install.packages("EBImage")
#endere√ßo para abertura de imagem
aux<-EBImage::readImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.png")
n <- nrow(aux)
m <- ncol(aux)
i <- 1
aux1 <- matrix(0,n,m)
while (i<length(aux1+1)) {
aux1[i] <- aux[i]
i <- i+1
}
i <- 1
aux2 <- matrix(0,n,m)
while (i<length(aux1+1)) {
aux2[i] <- aux[i+n*m]
i <- i+1
}
i <- 1
aux3 <- matrix(0,n,m)
while (i<length(aux1+1)) {
aux3[i] <- aux[i+2*n*m]
i <- i+1
}
aux <- (0.3*aux1 + 0.59*aux2 + 0.11*aux3)
otsu <- EBImage::otsu(aux)
otsuimg <- aux > otsu
EBImage::display(aux)
EBImage::display(otsuimg)
#endere√ßo para abertura de imagem
getwd()
update.packages(ask = FALSE)
#endere√ßo para abertura de imagem
getwd()
getwd()
b1 <- rasterImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.png")
aux<-EBImage::readImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.png")
install.packages("IBImage")
b1 <- rasterImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.tif", xleft)
#endere√ßo para abertura de imagem
getwd()
update.packages(ask = FALSE)
b1 <- rasterImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.tif", xleft)
b1 <- rasterImage("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/
00_Projeto de pesquisa/Imagens_de_satelite
/Satelite_aqua/AQUA.250M_TrueColor.2021_08_21.16_11_41.tif", xleft)
library(imager)
install.packages("imager")
library(EBImage)
install.packages("EBImage")
library(EBImage)
library(imager)
install.packages("EBImage")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("EBImage")
library(EBImage)
library(imager)
install.packages("TSstudio")
#Obtendo a base de dados para o exemplo
USgas<- TSstudio::USgas
#Dividindo a base de dados em s√É¬©rie de treinamento e para teste usando
## fun√É¬ß√É¬£o windows
treino <- window(USgas, start = time(USgas)[1],
end = time(USgas)[length(USgas) - 12])
teste <- window(USgas, start = time(USgas)[length(USgas) - 12 + 1],
end = time(USgas)[length(USgas)])
TSstudio::ts_info(teste)
# usando a fun√É¬ß√É¬£o windows ts_split do pacote TSstudio
USgas_partitions <- TSstudio::ts_split(USgas, sample.out = 12)
treino <- USgas_partitions$train
teste <- USgas_partitions$test
#Determinando o modelo automaticamente pela fun√É¬ß√É¬£o auto.arima
## com a s√É¬©rie de treino
md <- forecast::auto.arima(treino)
#Verificando os res√É≠duos do modelo
f.arima1<-forecast::checkresiduals(md)
f.arima1
#Obtendo o valor previsto para 12 per√É≠odos usando o modelo md
fc <- forecast::forecast(md, h = 12)
#Testando a acur√É¬°ria do modelo md comparando o s√É¬©rie de teste
forecast::accuracy(fc, teste)
TSstudio::test_forecast(actual = USgas,
forecast.obj = fc,
test = teste)
#Utilizando o modelo "naive" como benchmark
naive_model <- forecast::naive(treino, h = 12)
#Obtendo o gr√É¬°fico para o valor previsto
TSstudio::test_forecast(actual = USgas,
forecast.obj = naive_model,
test = teste)
#Analisando a acur√É¬°cia do modelo naive
forecast::accuracy(naive_model, teste)
#Obtendo o modelo final
md_final <- forecast::auto.arima(USgas)
fc_final <- forecast::forecast(md_final, h = 12)
#Apagar mem√≥ria
remove(list = ls())
#Ativar pacote
library(EBImage)
library(imager)
#Indicar pasta de trabalho
setwd("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Image_CBERS_4_MUX")
#Fun√ß√£o para transformar em escala de cinza,
#realizar a limiariza√ß√£o das imagens e c√°lculo da √°rea
#do espelho d'√°gua.
para.image <- function(date,image) {
image1 <- as.cimg(image)
grayimage <- grayscale(image1)
otsuimage <- grayimage > EBImage::otsu(grayimage)
#display(otsuimage)
main_image <- 1-otsuimage
#display(main_image)
#Colocar fun√ß√£o Cut.
#C√°lculo da √°rea
aux <- sum(main_image)
#Resolu√ß√£o da imagem MUX de 20m,
#logo √°rea de 1 pixel igual a 400m¬≤.
pixel <- 400
dim.area <- pixel*aux
saida <- data.frame(data=date,area=dim.area)
return(saida)
}
#Cria√ß√£o de lista de imagens
files_Path <- list.files(path = "C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Image_CBERS_4_MUX")
files_Path
nfiles <- length(files_Path)
data_result = data.frame(matrix(ncol = 2, nrow = nfiles))
colnames(data_result) = c("data", "area")
#Loop para acessar cada imagem, separar data e cort√°-las
#para refinar a avalia√ß√£o da √°rea do espelho d'√°gua do rio.
for (i in 1:nfiles) {
name_i <- files_Path[i]
namei_split <- strsplit(name_i, split = "_")[[1]]
date = namei_split[4]
image <- EBImage::readImage(name_i)
#Colocar fun√ß√£o Cut. Usar na pr√≥
#image_transformed = cut.image
data_result[i,] <- para.image(date,image)# image_transformed
}#View(data_result)
#Csv com dados de data e √°reas
write.csv(data_result, file = "areas.csv",row.names = F)
#Transformando o data frame em series temporais
library(forecast)
dados.ts<-ts(data_result$area)
#dados.ts<-ts(data_result$area, frequency = 12, start = c(2015,6))
dados.ts
plot(dados.ts)
dados.ts<-ts(data_result$area, frequency = 12, start = c(2015,6))
dados.ts
plot(dados.ts)
dados.ts<-ts(data_result$area)
#dados.ts<-ts(data_result$area, frequency = 12, start = c(2015,6))
dados.ts
plot(dados.ts)
#N√£o sabemos o padr√£o dos dados.
#Gerar fun√ß√£o de Auto correla√ß√£o (ACF) e PACF (Parcial)
tsm::ac(dados.ts, max.lag = 10)
model_arima = auto.arima(y = dados.ts)
model_arima
plot(forecast(model_arima, h=2))
plot(forecast(model_arima, h=2))
plot(forecast(model_arima, h=2))
lines(model_arima$fitted, col = 2)
previsao = forecast(model_arima, h=2)
previsao
previsao
#Indicar pasta de trabalho
setwd("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Image_CBERS_4_MUX")
#Indicar pasta de trabalho
setwd("C:/Users/hever/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Codigo")
image <- EBImage::readImage("02.png")
image1 <- as.cimg(image)
grayimage <- grayscale(image1)
otsuimage <- grayimage > EBImage::otsu(grayimage)
display(otsuimage)
main_image <- 1-otsuimage
display(main_image)
#Apagar mem√≥ria
remove(list = ls())
#Ativar pacotes
library(EBImage)
library(imager)
library(forecast)
#Indicar pasta de trabalho
setwd("C:/Users/Heverton/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Image_LANDSAT_KIRWIN_CUT")
#Fun√ß√£o para transformar em escala de cinza,
#realizar a limiariza√ß√£o das imagens e c√°lculo da √°rea alagada
para.image <- function(date,image) {
image1 <- as.cimg(image)
grayimage <- grayscale(image1)
otsuimage <- grayimage > EBImage::otsu(grayimage)
#C√°lculo da √°rea
aux <- sum(otsuimage)
pixel <- 900  # Resolu√ß√£o 30m
dim.area <- pixel*aux
saida <- data.frame(data=date,area=dim.area)
return(saida)
}
#Cria√ß√£o de lista de imagens
files_Path <- list.files(path = "C:/Users/Heverton/OneDrive/Mestrado UFCA/Disciplinas/00_Projeto_de_pesquisa/Imagens_de_satelite/Image_LANDSAT_KIRWIN_CUT")
files_Path
nfiles <- length(files_Path)
data_result = data.frame(matrix(ncol = 2, nrow = nfiles))
colnames(data_result) = c("data", "area")
#Loop para acessar cada imagem, separarando data e √°rea alagada.
for (i in 1:nfiles) {
name_i <- files_Path[i]
namei_split <- strsplit(name_i, split = "_")[[1]]
date = namei_split[4]
image <- EBImage::readImage(name_i)
data_result[i,] <- para.image(date,image)# image_transformed
}
#Transformando o data frame em series temporais
#dados.ts<-ts(data_result$area)
dados.ts<-ts(data_result$area, frequency = 12, start = 2013)
dados.ts
plot(dados.ts, ylab="√Årea alagada em m¬≤", main="S√©rie temporal")
#Modelagem
#Aplica√ß√£o do log devido dados maiores que zero.
y = ts(log(data_result$area),frequency=12)
lts = y
plot(lts, ylab="log de √°rea alagada", main= "S√©rie temporal")
##seperar dados de treinamento
se<-0.899*length(lts)
tr<-length(lts)-se
trainning<-subset(lts,end = length(lts)-tr)
lines(trainning,col="red")
#pegar outra parte da s√©rie para valida√ß√£o
test<-subset(lts,start = length(lts)-(tr-1))
lines(test,col="green")
trainning
test
# acf(resid(fit)) #Correla√ß√£o
# pacf(resid(fit)) #Correla√ß√£o parcial
# par(mfrow=c(1,1))
# plot(lts)
# plot(fit)
# predict(fit,n.ahead = tr)
# forecast<-predict(fit,n.ahead = tr)
# plot(lts,ylim=c(16,17))
# lines(forecast,lwd=2,col="blue")
#
model_arima = auto.arima(y = y, D=1)
model_arima
summary(model_arima)
qqnorm(model_arima$residuals)
qqline(model_arima$residuals)
shapiro.test(model_arima$residuals)
acf(model_arima$residuals)
pacf(model_arima$residuals)
hist(model_arima$residuals)
auto.arima(model_arima$residuals)
previsao<-exp(forecast(model_arima, h=12)$mean)
previsao
plot(c(exp(model_arima$fitted), previsao), type = "l", col="red")
lines(data_result$area)
plot(x= as.numeric(exp(model_arima$fitted)),
y = data_result$area, type = "p")
modelo_linear<-lm(data_result$area~exp(model_arima$fitted))
abline(modelo_linear)
summary(modelo_linear)
